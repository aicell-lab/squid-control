<!DOCTYPE html>  
<html lang="en">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport" content="width=device-width, initial-scale=1.0">  
    <title>Microscopy Image Viewer (WebRTC)</title>  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@7.3.0/ol.css">  
    <script src="https://cdn.jsdelivr.net/npm/ol@7.3.0/dist/ol.js"></script>  
    <script src="https://cdn.jsdelivr.net/npm/hypha-rpc@latest/dist/hypha-rpc-websocket.min.js"></script>  
    <style>  
        body {  
            margin: 0;  
            padding: 0;  
        }  
        #map {  
            width: 100%;  
            height: 100vh;  
        }  
        #videoStream {  
            position: absolute;  
            top: 0;  
            left: 0;  
            pointer-events: none;  
            opacity: 0;  
        }  
    </style>  
</head>  
<body>  
    <div id="map"></div>  
    <video id="videoStream" autoplay playsinline></video>  

    <script>  
        async function initializeViewer() {  
            // Connect to Hypha server  
            token = await hyphaWebsocketClient.login({"server_url": "https://hypha.aicell.io",
                workspace: "agent-lens"})
            const server = await hyphaWebsocketClient.connectToServer({  
                "server_url": "https://hypha.aicell.io",
                workspace: "agent-lens",
                token: token
            });  

            // Connect to the tile streaming service  
            const rtcConnection = await hyphaWebsocketClient.getRTCService(server, "microscopy-tile-stream");  

            // Get metadata service  
            const metadataService = await server.getService("microscopy-tile-service");  
            const metadata = await metadataService.get_metadata();  

            // Set up WebRTC video element  
            const videoElement = document.getElementById('videoStream');  

            // Handle incoming video stream  
            rtcConnection.ontrack = (event) => {  
                if (event.track.kind === 'video') {  
                    videoElement.srcObject = new MediaStream([event.track]);  
                }  
            };  

            // Create data channel for sending coordinates  
            const dataChannel = rtcConnection.createDataChannel('tileCoords');  
            dataChannel.onopen = () => console.log('Data channel opened');  
            dataChannel.onerror = (error) => console.error('Data channel error:', error);  

            // Define the resolutions  
            const resolutions = [  
                1, 1/2, 1/4, 1/8, 1/16, 1/32, 1/64  
            ];  

            const imageWidth = metadata.tile_size * 64;  // Adjust based on your data  
            const imageHeight = metadata.tile_size * 64;  
            const extent = [0, 0, imageWidth, imageHeight];  

            // Create custom tile grid  
            const tileGrid = new ol.tilegrid.TileGrid({  
                extent: extent,  
                resolutions: resolutions,  
                tileSize: metadata.tile_size,  
            });  

            // Create a custom tile layer that uses WebRTC  
            const tileLayer = new ol.layer.Tile({  
                source: new ol.source.TileImage({  
                    tileGrid: tileGrid,  
                    tileLoadFunction: (imageTile, src) => {  
                        // Parse coordinates from src  
                        const coords = src.match(/\/(\d+)\/(\d+)\/(\d+)/);  
                        if (coords) {  
                            const [_, z, x, y] = coords;  
                            // Send coordinates through data channel  
                            if (dataChannel.readyState === 'open') {  
                                dataChannel.send(JSON.stringify({  
                                    coords: { z: parseInt(z), x: parseInt(x), y: parseInt(y) }  
                                }));  
                            }  
                        }  
                    },  
                    url: 'dummy/{z}/{x}/{y}' // Dummy URL for OpenLayers  
                })  
            });  

            // Create the map view  
            const view = new ol.View({  
                center: [imageWidth / 2, imageHeight / 2],  
                zoom: 0,  
                maxZoom: resolutions.length - 1,  
                minZoom: 0,  
                resolutions: resolutions,  
            });  

            // Create the map  
            const map = new ol.Map({  
                target: 'map',  
                layers: [tileLayer],  
                view: view,  
            });  

            // Handle map movement  
            map.on('moveend', () => {  
                const center = view.getCenter();  
                const zoom = view.getZoom();  

                // Calculate visible tiles  
                const extent = view.calculateExtent(map.getSize());  
                const z = Math.floor(zoom);  
                const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);  

                // Send current viewport info  
                if (dataChannel.readyState === 'open') {  
                    dataChannel.send(JSON.stringify({  
                        viewport: {  
                            center,  
                            zoom,  
                            extent: extent,  
                            tileRange: {  
                                minX: tileRange.minX,  
                                minY: tileRange.minY,  
                                maxX: tileRange.maxX,  
                                maxY: tileRange.maxY  
                            }  
                        }  
                    }));  
                }  
            });  

            // Handle channel switching (if needed)  
            function switchChannel(channelName) {  
                if (dataChannel.readyState === 'open') {  
                    dataChannel.send(JSON.stringify({  
                        channel: channelName  
                    }));  
                }  
            }  
        }  

        // Initialize the viewer  
        initializeViewer().catch(console.error);  
    </script>  
</body>  
</html>  